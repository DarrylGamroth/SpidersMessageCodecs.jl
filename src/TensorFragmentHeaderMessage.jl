# Generated SBE (Simple Binary Encoding) message codec
# Code generated by SBE. DO NOT EDIT.

export TensorFragmentHeaderMessage, TensorFragmentHeaderMessageDecoder, TensorFragmentHeaderMessageEncoder
abstract type TensorFragmentHeaderMessage{T} end

struct TensorFragmentHeaderMessageDecoder{T<:AbstractArray{UInt8}} <: TensorFragmentHeaderMessage{T}
    buffer::T
    offset::Int64
    position_ptr::Base.RefValue{Int64}
    acting_block_length::UInt16
    acting_version::UInt16
    function TensorFragmentHeaderMessageDecoder(buffer::T, offset::Int64, position_ptr::Base.RefValue{Int64},
        acting_block_length::Integer, acting_version::Integer) where {T}
        position_ptr[] = offset + acting_block_length
        new{T}(buffer, offset, position_ptr, acting_block_length, acting_version)
    end
end

struct TensorFragmentHeaderMessageEncoder{T<:AbstractArray{UInt8}} <: TensorFragmentHeaderMessage{T}
    buffer::T
    offset::Int64
    position_ptr::Base.RefValue{Int64}
    function TensorFragmentHeaderMessageEncoder(buffer::T, offset::Int64, position_ptr::Base.RefValue{Int64}) where {T}
        position_ptr[] = offset + 68
        new{T}(buffer, offset, position_ptr)
    end
end

@inline function TensorFragmentHeaderMessageDecoder(buffer::AbstractArray, offset::Int64=0;
    position_ptr::Base.RefValue{Int64}=Ref(0),
    header::MessageHeader=MessageHeader(buffer, offset))
    if templateId(header) != UInt16(0xe) || schemaId(header) != UInt16(0x1)
        error("Template id or schema id mismatch")
    end
    TensorFragmentHeaderMessageDecoder(buffer, offset + sbe_encoded_length(header), position_ptr,
        blockLength(header), version(header))
end
@inline function TensorFragmentHeaderMessageEncoder(buffer::AbstractArray, offset::Int64=0;
    position_ptr::Base.RefValue{Int64}=Ref(0),
    header::MessageHeader=MessageHeader(buffer, offset))
    blockLength!(header, UInt16(0x44))
    templateId!(header, UInt16(0xe))
    schemaId!(header, UInt16(0x1))
    version!(header, UInt16(0x0))
    TensorFragmentHeaderMessageEncoder(buffer, offset + sbe_encoded_length(header), position_ptr)
end
sbe_buffer(m::TensorFragmentHeaderMessage) = m.buffer
sbe_offset(m::TensorFragmentHeaderMessage) = m.offset
sbe_position_ptr(m::TensorFragmentHeaderMessage) = m.position_ptr
sbe_position(m::TensorFragmentHeaderMessage) = m.position_ptr[]
sbe_position!(m::TensorFragmentHeaderMessage, position) = m.position_ptr[] = position
sbe_block_length(::TensorFragmentHeaderMessage) = UInt16(0x44)
sbe_block_length(::Type{<:TensorFragmentHeaderMessage}) = UInt16(0x44)
sbe_template_id(::TensorFragmentHeaderMessage) = UInt16(0xe)
sbe_template_id(::Type{<:TensorFragmentHeaderMessage})  = UInt16(0xe)
sbe_schema_id(::TensorFragmentHeaderMessage) = UInt16(0x1)
sbe_schema_id(::Type{<:TensorFragmentHeaderMessage})  = UInt16(0x1)
sbe_schema_version(::TensorFragmentHeaderMessage) = UInt16(0x0)
sbe_schema_version(::Type{<:TensorFragmentHeaderMessage})  = UInt16(0x0)
sbe_semantic_type(::TensorFragmentHeaderMessage) = ""
sbe_semantic_version(::TensorFragmentHeaderMessage) = ""
sbe_acting_block_length(m::TensorFragmentHeaderMessageDecoder) = m.acting_block_length
sbe_acting_block_length(::TensorFragmentHeaderMessageEncoder) = UInt16(0x44)
sbe_acting_version(m::TensorFragmentHeaderMessageDecoder) = m.acting_version
sbe_acting_version(::TensorFragmentHeaderMessageEncoder) = UInt16(0x0)
sbe_rewind!(m::TensorFragmentHeaderMessage) = sbe_position!(m, m.offset + sbe_acting_block_length(m))
sbe_encoded_length(m::TensorFragmentHeaderMessage) = sbe_position(m) - m.offset
@inline function sbe_decoded_length(m::TensorFragmentHeaderMessage)
    skipper = TensorFragmentHeaderMessageDecoder(sbe_buffer(m), sbe_offset(m), Ref(0),
        sbe_acting_block_length(m), sbe_acting_version(m))
    sbe_skip!(skipper)
    sbe_encoded_length(skipper)
end

function header_meta_attribute(::TensorFragmentHeaderMessage, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
header_id(::TensorFragmentHeaderMessage) = UInt16(0x1)
header_since_version(::TensorFragmentHeaderMessage) = UInt16(0x0)
header_in_acting_version(m::TensorFragmentHeaderMessage) = sbe_acting_version(m) >= UInt16(0x0)
header_encoding_offset(::TensorFragmentHeaderMessage) = 0
header(m::TensorFragmentHeaderMessage) = SpidersMessageHeader(m.buffer, m.offset + 0, sbe_acting_version(m))

function format_meta_attribute(::TensorFragmentHeaderMessage, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
format_id(::TensorFragmentHeaderMessage) = UInt16(0x2)
format_since_version(::TensorFragmentHeaderMessage) = UInt16(0x0)
format_in_acting_version(m::TensorFragmentHeaderMessage) = sbe_acting_version(m) >= UInt16(0x0)
format_encoding_offset(::TensorFragmentHeaderMessage) = 64
format_encoding_length(::TensorFragmentHeaderMessage) = 1
@inline function format(::Type{Integer}, m::TensorFragmentHeaderMessageDecoder)
    return decode_le(Int8, m.buffer, m.offset + 64)
end
@inline function format(m::TensorFragmentHeaderMessageDecoder)
    return Format.SbeEnum(decode_le(Int8, m.buffer, m.offset + 64))
end
@inline format!(m::TensorFragmentHeaderMessageEncoder, value::Format.SbeEnum) = encode_le(Int8, m.buffer, m.offset + 64, Int8(value))

function order_meta_attribute(::TensorFragmentHeaderMessage, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
order_id(::TensorFragmentHeaderMessage) = UInt16(0x3)
order_since_version(::TensorFragmentHeaderMessage) = UInt16(0x0)
order_in_acting_version(m::TensorFragmentHeaderMessage) = sbe_acting_version(m) >= UInt16(0x0)
order_encoding_offset(::TensorFragmentHeaderMessage) = 65
order_encoding_length(::TensorFragmentHeaderMessage) = 1
@inline function order(::Type{Integer}, m::TensorFragmentHeaderMessageDecoder)
    return decode_le(Int8, m.buffer, m.offset + 65)
end
@inline function order(m::TensorFragmentHeaderMessageDecoder)
    return MajorOrder.SbeEnum(decode_le(Int8, m.buffer, m.offset + 65))
end
@inline order!(m::TensorFragmentHeaderMessageEncoder, value::MajorOrder.SbeEnum) = encode_le(Int8, m.buffer, m.offset + 65, Int8(value))

function reserved1_meta_attribute(::TensorFragmentHeaderMessage, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
reserved1_id(::TensorFragmentHeaderMessage) = UInt16(0x4)
reserved1_since_version(::TensorFragmentHeaderMessage) = UInt16(0x0)
reserved1_in_acting_version(m::TensorFragmentHeaderMessage) = sbe_acting_version(m) >= UInt16(0x0)
reserved1_encoding_offset(::TensorFragmentHeaderMessage) = 66
reserved1_null_value(::TensorFragmentHeaderMessage) = Int8(-128)
reserved1_min_value(::TensorFragmentHeaderMessage) = Int8(-127)
reserved1_max_value(::TensorFragmentHeaderMessage) = Int8(127)
reserved1_encoding_length(::TensorFragmentHeaderMessage) = 2
reserved1_length(::TensorFragmentHeaderMessage) = 2
reserved1_eltype(::TensorFragmentHeaderMessage) = Int8

@inline function reserved1(m::TensorFragmentHeaderMessageDecoder)
    return mappedarray(ltoh, reinterpret(Int8, view(m.buffer, m.offset+66+1:m.offset+66+sizeof(Int8)*2)))
end

@inline function reserved1(::Type{<:SVector},m::TensorFragmentHeaderMessageDecoder)
    return mappedarray(ltoh, reinterpret(SVector{2,Int8}, view(m.buffer, m.offset+66+1:m.offset+66+sizeof(Int8)*2))[])
end

@inline function reserved1!(m::TensorFragmentHeaderMessageEncoder)
    return mappedarray(ltoh, htol, reinterpret(Int8, view(m.buffer, m.offset+66+1:m.offset+66+sizeof(Int8)*2)))
end

@inline function reserved1!(m::TensorFragmentHeaderMessageEncoder, value)
    copyto!(reserved1!(m), value)
end

export Group, GroupDecoder, GroupEncoder
abstract type Group{T} end

mutable struct GroupDecoder{T<:AbstractArray{UInt8}} <: Group{T}
    const buffer::T
    offset::Int64
    const position_ptr::Base.RefValue{Int64}
    const block_length::UInt16
    const acting_version::UInt16
    const count::UInt16
    index::UInt16
    function GroupDecoder(buffer::T, offset::Int64, position_ptr::Base.RefValue{Int64},
        block_length::Integer, acting_version::Integer,
        count::Integer, index::Integer) where {T}
        new{T}(buffer, offset, position_ptr, block_length, acting_version, count, index)
    end
end

mutable struct GroupEncoder{T<:AbstractArray{UInt8}} <: Group{T}
    const buffer::T
    offset::Int64
    const position_ptr::Base.RefValue{Int64}
    const initial_position::Int64
    const count::UInt16
    index::UInt16
    function GroupEncoder(buffer::T, offset::Int64, position_ptr::Base.RefValue{Int64},
        initial_position::Int64, count::Integer, index::Integer) where {T}
        new{T}(buffer, offset, position_ptr, initial_position, count, index)
    end
end

@inline function GroupDecoder(buffer, position_ptr, acting_version)
    dimensions = GroupSizeEncoding(buffer, position_ptr[])
    position_ptr[] += 4
    return GroupDecoder(buffer, 0, position_ptr, blockLength(dimensions),
        acting_version, numInGroup(dimensions), 0)
end

@inline function GroupEncoder(buffer, count, position_ptr)
    if count > 65534
        error("count outside of allowed range")
    end
    dimensions = GroupSizeEncoding(buffer, position_ptr[])
    blockLength!(dimensions, UInt16(0x4))
    numInGroup!(dimensions, count)
    initial_position = position_ptr[]
    position_ptr[] += 4
    return GroupEncoder(buffer, 0, position_ptr, initial_position, count, 0)
end

sbe_header_size(::Group) = 4
sbe_block_length(::Group) = UInt16(0x4)
sbe_acting_block_length(g::GroupDecoder) = g.block_length
sbe_acting_block_length(g::GroupEncoder) = UInt16(0x4)
sbe_acting_version(g::GroupDecoder) = g.acting_version
sbe_position(g::Group) = g.position_ptr[]
@inline sbe_position!(g::Group, position) = g.position_ptr[] = position
sbe_position_ptr(g::Group) = g.position_ptr
@inline function next!(g::Group)
    if g.index >= g.count
        error("index >= count")
    end
    g.offset = sbe_position(g)
    sbe_position!(g, g.offset + sbe_acting_block_length(g))
    g.index += 1
    return g
end
function Base.iterate(g::Group, state=nothing)
    if g.index < g.count
        g.offset = sbe_position(g)
        sbe_position!(g, g.offset + sbe_acting_block_length(g))
        g.index += 1
        return g, state
    else
        return nothing
    end
end
Base.eltype(::Type{<:Group}) = Group
Base.isdone(g::Group, state=nothing) = g.index >= g.count
Base.length(g::Group) = g.count

function reset_count_to_index!(g::GroupEncoder)
    g.count = g.index
    dimensions = GroupSizeEncoding(g.buffer, g.initial_position)
    numInGroup!(dimensions, g.count)
    return g.count
end

function groupField1_meta_attribute(::Group, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
groupField1_id(::Group) = UInt16(0xb)
groupField1_since_version(::Group) = UInt16(0x0)
groupField1_in_acting_version(m::Group) = sbe_acting_version(m) >= UInt16(0x0)
groupField1_encoding_offset(::Group) = 0
groupField1_null_value(::Group) = Int32(-2147483648)
groupField1_min_value(::Group) = Int32(-2147483647)
groupField1_max_value(::Group) = Int32(2147483647)
groupField1_encoding_length(::Group) = 4

@inline function groupField1(m::GroupDecoder)
    return decode_le(Int32, m.buffer, m.offset + 0)
end
@inline groupField1!(m::GroupEncoder, value) = encode_le(Int32, m.buffer, m.offset + 0, value)

function show(io::IO, writer::Group{T}) where {T}
    println(io, "Group view over a type $T")
    print(io, "groupField1: ")
    print(io, groupField1(writer))

end

@inline function sbe_skip!(m::Group)
    
    return
end

@inline function group(m::TensorFragmentHeaderMessage)
    return GroupDecoder(m.buffer, sbe_position_ptr(m), sbe_acting_version(m))
end

@inline function group!(m::TensorFragmentHeaderMessage, count)
    return GroupEncoder(m.buffer, count, sbe_position_ptr(m))
end
group_group_count!(m::TensorFragmentHeaderMessageEncoder, count) = group!(m, count)
group_id(::TensorFragmentHeaderMessage) = 23
group_since_version(::TensorFragmentHeaderMessage) = 0
group_in_acting_version(m::TensorFragmentHeaderMessage) = sbe_acting_version(m) >= 0

function dims_meta_attribute(::TensorFragmentHeaderMessage, meta_attribute)
    meta_attribute === :semantic_type && return Symbol("int32")
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

dims_character_encoding(::TensorFragmentHeaderMessage) = "null"
dims_in_acting_version(m::TensorFragmentHeaderMessage) = sbe_acting_version(m) >= 0
dims_id(::TensorFragmentHeaderMessage) = 20
dims_header_length(::TensorFragmentHeaderMessage) = 4

@inline function dims_length(m::TensorFragmentHeaderMessage)
    return decode_le(UInt32, m.buffer, sbe_position(m))
end

@inline function dims_length!(m::TensorFragmentHeaderMessageEncoder, n)
    if !checkbounds(Bool, m.buffer, sbe_position(m) + 4 + n)
        error("buffer too short for data length")
    elseif n > 1073741824
        error("data length too large for length type")
    end
    return encode_le(UInt32, m.buffer, sbe_position(m), n)
end

@inline function skip_dims!(m::TensorFragmentHeaderMessage)
    len = dims_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return len
end

@inline function dims(m::TensorFragmentHeaderMessageDecoder)
    len = dims_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function dims!(m::TensorFragmentHeaderMessageEncoder; length::Int64)
    dims_length!(m, length)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + length)
    return view(m.buffer, pos+1:pos+length)
end

@inline function dims!(m::TensorFragmentHeaderMessageEncoder, src)
    len = Base.length(src)
    dims_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, src)
end

function offset_meta_attribute(::TensorFragmentHeaderMessage, meta_attribute)
    meta_attribute === :semantic_type && return Symbol("int32")
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

offset_character_encoding(::TensorFragmentHeaderMessage) = "null"
offset_in_acting_version(m::TensorFragmentHeaderMessage) = sbe_acting_version(m) >= 0
offset_id(::TensorFragmentHeaderMessage) = 21
offset_header_length(::TensorFragmentHeaderMessage) = 4

@inline function offset_length(m::TensorFragmentHeaderMessage)
    return decode_le(UInt32, m.buffer, sbe_position(m))
end

@inline function offset_length!(m::TensorFragmentHeaderMessageEncoder, n)
    if !checkbounds(Bool, m.buffer, sbe_position(m) + 4 + n)
        error("buffer too short for data length")
    elseif n > 1073741824
        error("data length too large for length type")
    end
    return encode_le(UInt32, m.buffer, sbe_position(m), n)
end

@inline function skip_offset!(m::TensorFragmentHeaderMessage)
    len = offset_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return len
end

@inline function offset(m::TensorFragmentHeaderMessageDecoder)
    len = offset_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function offset!(m::TensorFragmentHeaderMessageEncoder; length::Int64)
    offset_length!(m, length)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + length)
    return view(m.buffer, pos+1:pos+length)
end

@inline function offset!(m::TensorFragmentHeaderMessageEncoder, src)
    len = Base.length(src)
    offset_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, src)
end

function show(io::IO, m::TensorFragmentHeaderMessage{T}) where {T}
    println(io, "TensorFragmentHeaderMessage view over a type $T")
    println(io, "SbeBlockLength: ", sbe_block_length(m))
    println(io, "SbeTemplateId:  ", sbe_template_id(m))
    println(io, "SbeSchemaId:    ", sbe_schema_id(m))
    println(io, "SbeSchemaVersion: ", sbe_schema_version(m))

    writer = TensorFragmentHeaderMessageDecoder(sbe_buffer(m), sbe_offset(m), Ref(0),
        sbe_block_length(m), sbe_schema_version(m))
    print(io, "header: ")
    show(io, header(writer))

    println(io)
    print(io, "format: ")
    print(io, format(writer))

    println(io)
    print(io, "order: ")
    print(io, order(writer))

    println(io)
    print(io, "reserved1: ")
    print(io, reserved1(writer))

    println(io)
    println(io, "Group:")
    for group in group(writer)
        show(io, group)
        println(io)
    end
    println(io)
    print(io, "dims: ")
    print(io, skip_dims!(writer))
    print(io, " bytes of raw data")

    println(io)
    print(io, "offset: ")
    print(io, skip_offset!(writer))
    print(io, " bytes of raw data")

    nothing
end

@inline function sbe_skip!(m::TensorFragmentHeaderMessage)
    sbe_rewind!(m)
    for group in group(m)
        sbe_skip!(group)
    end
    skip_dims!(m)
    skip_offset!(m)
    return
end
