# Generated SBE (Simple Binary Encoding) message codec
# Code generated by SBE. DO NOT EDIT.

export EventMessage, EventMessageDecoder, EventMessageEncoder
abstract type EventMessage{T} end

struct EventMessageDecoder{T<:AbstractArray{UInt8}} <: EventMessage{T}
    buffer::T
    offset::Int64
    position_ptr::Base.RefValue{Int64}
    acting_block_length::UInt16
    acting_version::UInt16
    function EventMessageDecoder(buffer::T, offset::Integer, position_ptr::Ref{Int64},
        acting_block_length::Integer, acting_version::Integer) where {T}
        position_ptr[] = offset + acting_block_length
        new{T}(buffer, offset, position_ptr, acting_block_length, acting_version)
    end
end

struct EventMessageEncoder{T<:AbstractArray{UInt8},HasSbeHeader} <: EventMessage{T}
    buffer::T
    offset::Int64
    position_ptr::Base.RefValue{Int64}
    function EventMessageEncoder(buffer::T, offset::Integer,
        position_ptr::Ref{Int64}, hasSbeHeader::Bool=false) where {T}
        position_ptr[] = offset + 100
        new{T,hasSbeHeader}(buffer, offset, position_ptr)
    end
end

@inline function EventMessageDecoder(buffer::AbstractArray, offset::Integer=0;
    position_ptr::Base.RefValue{Int64}=Ref(0),
    header::MessageHeader=MessageHeader(buffer, offset))
    if templateId(header) != UInt16(0x1) || schemaId(header) != UInt16(0x1)
        throw(DomainError("Template id or schema id mismatch"))
    end
    EventMessageDecoder(buffer, offset + sbe_encoded_length(header), position_ptr,
        blockLength(header), version(header))
end
@inline function EventMessageEncoder(buffer::AbstractArray, offset::Integer=0;
    position_ptr::Base.RefValue{Int64}=Ref(0),
    header::MessageHeader=MessageHeader(buffer, offset))
    blockLength!(header, UInt16(0x64))
    templateId!(header, UInt16(0x1))
    schemaId!(header, UInt16(0x1))
    version!(header, UInt16(0x0))
    EventMessageEncoder(buffer, offset + sbe_encoded_length(header), position_ptr, true)
end
sbe_buffer(m::EventMessage) = m.buffer
sbe_offset(m::EventMessage) = m.offset
sbe_position_ptr(m::EventMessage) = m.position_ptr
sbe_position(m::EventMessage) = m.position_ptr[]
sbe_position!(m::EventMessage, position) = m.position_ptr[] = position
sbe_block_length(::EventMessage) = UInt16(0x64)
sbe_block_length(::Type{<:EventMessage}) = UInt16(0x64)
sbe_template_id(::EventMessage) = UInt16(0x1)
sbe_template_id(::Type{<:EventMessage})  = UInt16(0x1)
sbe_schema_id(::EventMessage) = UInt16(0x1)
sbe_schema_id(::Type{<:EventMessage})  = UInt16(0x1)
sbe_schema_version(::EventMessage) = UInt16(0x0)
sbe_schema_version(::Type{<:EventMessage})  = UInt16(0x0)
sbe_semantic_type(::EventMessage) = ""
sbe_semantic_version(::EventMessage) = ""
sbe_acting_block_length(m::EventMessageDecoder) = m.acting_block_length
sbe_acting_block_length(::EventMessageEncoder) = UInt16(0x64)
sbe_acting_version(m::EventMessageDecoder) = m.acting_version
sbe_acting_version(::EventMessageEncoder) = UInt16(0x0)
sbe_rewind!(m::EventMessage) = sbe_position!(m, m.offset + sbe_acting_block_length(m))
sbe_encoded_length(m::EventMessage) = sbe_position(m) - m.offset
@inline function sbe_decoded_length(m::EventMessage)
    skipper = EventMessageDecoder(sbe_buffer(m), sbe_offset(m), Ref(0),
        sbe_acting_block_length(m), sbe_acting_version(m))
    sbe_skip!(skipper)
    sbe_encoded_length(skipper)
end

Base.sizeof(m::EventMessage) = sbe_decoded_length(m)
function Base.convert(::Type{AbstractArray{UInt8}}, m::EventMessageEncoder{<:AbstractArray{UInt8},true})
    return view(m.buffer, m.offset+1-sbe_encoded_length(MessageHeader):m.offset+sbe_encoded_length(m))
end
function Base.convert(::Type{AbstractArray{UInt8}}, m::EventMessageEncoder{<:AbstractArray{UInt8},false})
    return view(m.buffer, m.offset+1:m.offset+sbe_encoded_length(m))
end

function header_meta_attribute(::EventMessage, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
header_id(::EventMessage) = UInt16(0x1)
header_since_version(::EventMessage) = UInt16(0x0)
header_in_acting_version(m::EventMessage) = sbe_acting_version(m) >= UInt16(0x0)
header_encoding_offset(::EventMessage) = 0
header(m::EventMessage) = SpidersMessageHeader(m.buffer, m.offset + 0, sbe_acting_version(m))

function format_meta_attribute(::EventMessage, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
format_id(::EventMessage) = UInt16(0x2)
format_since_version(::EventMessage) = UInt16(0x0)
format_in_acting_version(m::EventMessage) = sbe_acting_version(m) >= UInt16(0x0)
format_encoding_offset(::EventMessage) = 64
format_encoding_length(::EventMessage) = 1
@inline function format(m::EventMessageDecoder, ::Type{Integer})
    return decode_le(Int8, m.buffer, m.offset + 64)
end
@inline function format(m::EventMessageDecoder)
    return Format.SbeEnum(decode_le(Int8, m.buffer, m.offset + 64))
end
@inline format!(m::EventMessageEncoder, value::Format.SbeEnum) = encode_le(Int8, m.buffer, m.offset + 64, Int8(value))

function reserved1_meta_attribute(::EventMessage, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
reserved1_id(::EventMessage) = UInt16(0x3)
reserved1_since_version(::EventMessage) = UInt16(0x0)
reserved1_in_acting_version(m::EventMessage) = sbe_acting_version(m) >= UInt16(0x0)
reserved1_encoding_offset(::EventMessage) = 65
reserved1_null_value(::EventMessage) = Int8(-128)
reserved1_min_value(::EventMessage) = Int8(-127)
reserved1_max_value(::EventMessage) = Int8(127)
reserved1_encoding_length(::EventMessage) = 3
reserved1_length(::EventMessage) = 3
reserved1_eltype(::EventMessage) = Int8

@inline function reserved1(m::EventMessageDecoder)
    return mappedarray(ltoh, reinterpret(Int8, view(m.buffer, m.offset+65+1:m.offset+65+sizeof(Int8)*3)))
end

@inline function reserved1(m::EventMessageDecoder, ::Type{<:SVector})
    return mappedarray(ltoh, reinterpret(SVector{3,Int8}, view(m.buffer, m.offset+65+1:m.offset+65+sizeof(Int8)*3))[])
end

@inline function reserved1!(m::EventMessageEncoder)
    return mappedarray(ltoh, htol, reinterpret(Int8, view(m.buffer, m.offset+65+1:m.offset+65+sizeof(Int8)*3)))
end

@inline function reserved1!(m::EventMessageEncoder, value)
    copyto!(reserved1!(m), value)
end

function key_meta_attribute(::EventMessage, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
key_id(::EventMessage) = UInt16(0xa)
key_since_version(::EventMessage) = UInt16(0x0)
key_in_acting_version(m::EventMessage) = sbe_acting_version(m) >= UInt16(0x0)
key_encoding_offset(::EventMessage) = 68
key_null_value(::EventMessage) = UInt8(0x0)
key_min_value(::EventMessage) = UInt8(0x20)
key_max_value(::EventMessage) = UInt8(0x7e)
key_encoding_length(::EventMessage) = 32
key_length(::EventMessage) = 32
key_eltype(::EventMessage) = UInt8

@inline function key(m::EventMessageDecoder)
    return mappedarray(ltoh, reinterpret(UInt8, view(m.buffer, m.offset+68+1:m.offset+68+sizeof(UInt8)*32)))
end

@inline function key(m::EventMessageDecoder, ::Type{<:SVector})
    return mappedarray(ltoh, reinterpret(SVector{32,UInt8}, view(m.buffer, m.offset+68+1:m.offset+68+sizeof(UInt8)*32))[])
end

@inline function key(m::EventMessageDecoder, ::Type{<:AbstractString})
    value = view(m.buffer, m.offset+1+68:m.offset+68+sizeof(UInt8)*32)
    return StringView(rstrip_nul(value))
end

@inline function key(m::EventMessageDecoder, ::Type{<:Symbol})
    Symbol(key(m, AbstractString))
end

@inline function key!(m::EventMessageEncoder)
    return mappedarray(ltoh, htol, reinterpret(UInt8, view(m.buffer, m.offset+68+1:m.offset+68+sizeof(UInt8)*32)))
end

@inline function key!(m::EventMessageEncoder, value)
    copyto!(key!(m), value)
end

@inline function key!(m::EventMessageEncoder, value::AbstractString)
    dest = key!(m)
    fill!(dest, 0)
    copyto!(dest, value)
end

@inline function key!(m::EventMessageEncoder, value::Symbol)
    key!(m, to_string(value))
end

function value_meta_attribute(::EventMessage, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

value_character_encoding(::EventMessage) = "null"
value_in_acting_version(m::EventMessage) = sbe_acting_version(m) >= 0
value_id(::EventMessage) = 20
value_header_length(::EventMessage) = 4

@inline function value_length(m::EventMessage)
    return decode_le(UInt32, m.buffer, sbe_position(m))
end

@inline function value_length!(m::EventMessageEncoder, n)
    @boundscheck n > 1073741824 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 4 + n)
    return encode_le(UInt32, m.buffer, sbe_position(m), n)
end

@inline function skip_value!(m::EventMessageDecoder)
    len = value_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return len
end

@inline function value(m::EventMessageDecoder)
    len = value_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline value(m::EventMessageDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, value(m))
@inline value(m::EventMessageDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, value(m)); ntuple(i -> x[i], Val(N)))
@inline value(m::EventMessageDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(value(m)))
@inline value(m::EventMessageDecoder, ::Type{T}) where {T<:Symbol} = Symbol(value(m, StringView))
@inline value(m::EventMessageDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, value(m))[]
@inline value(m::EventMessageDecoder, ::Type{T}) where {T<:Nothing} = (skip_value!(m); nothing)

@inline function value_buffer!(m::EventMessageEncoder, len)
    value_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function value!(m::EventMessageEncoder, src::AbstractArray)
    len = sizeof(src)
    value_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function value!(m::EventMessageEncoder, src::NTuple)
    len = sizeof(src)
    value_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function value!(m::EventMessageEncoder, src::AbstractString)
    len = sizeof(src)
    value_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline value!(m::EventMessageEncoder, src::Symbol) = value!(m, to_string(src))
@inline value!(m::EventMessageEncoder, src::StaticString) = value!(m, Tuple(src))
@inline value!(m::EventMessageEncoder, src::Real) = value!(m, Tuple(src))
@inline value!(m::EventMessageEncoder, ::Nothing) = value_buffer!(m, 0)

function show(io::IO, m::EventMessage{T}) where {T}
    println(io, "EventMessage view over a type $T")
    println(io, "SbeBlockLength: ", sbe_block_length(m))
    println(io, "SbeTemplateId:  ", sbe_template_id(m))
    println(io, "SbeSchemaId:    ", sbe_schema_id(m))
    println(io, "SbeSchemaVersion: ", sbe_schema_version(m))

    writer = EventMessageDecoder(sbe_buffer(m), sbe_offset(m), Ref(0),
        sbe_block_length(m), sbe_schema_version(m))
    print(io, "header: ")
    show(io, header(writer))

    println(io)
    print(io, "format: ")
    print(io, format(writer))

    println(io)
    print(io, "reserved1: ")
    print(io, reserved1(writer))

    println(io)
    print(io, "key: ")
    print(io, "\"")
    print(io, key(writer, StringView))
    print(io, "\"")

    println(io)
    print(io, "value: ")
    print(io, skip_value!(writer))
    print(io, " bytes of raw data")

    nothing
end

@inline function sbe_skip!(m::EventMessageDecoder)
    sbe_rewind!(m)
    skip_value!(m)
    return
end
